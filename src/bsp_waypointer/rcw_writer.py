"""
RCW Writer Module for BSP Waypoint Generator.

Writes waypoints to RCBot2's .rcw waypoint file format.
"""

from __future__ import annotations

import struct
from dataclasses import dataclass
from pathlib import Path
from typing import BinaryIO, List, Optional

from .constants import HL2DMWaypointSubType, WaypointFlag
from .waypoint_converter import Waypoint


# RCW file format constants
RCW_MAGIC = b"RCW\x00"  # File signature
RCW_VERSION = 4  # RCBot2 waypoint version
MAX_WAYPOINT_CONNECTIONS = 8  # Maximum connections per waypoint in file format


@dataclass
class RCWHeader:
    """RCW file header structure."""
    magic: bytes = RCW_MAGIC
    version: int = RCW_VERSION
    num_waypoints: int = 0
    map_name: str = ""
    author: str = ""


class RCWWriter:
    """
    Writes waypoints to RCBot2 .rcw format.

    File format:
    - Header: magic (4 bytes) + version (4 bytes) + count (4 bytes)
    - For each waypoint:
      - Position: x, y, z (3 floats, 12 bytes)
      - Flags: (4 bytes int)
      - Radius: (4 bytes float)
      - Area: (4 bytes int) - for team/area restrictions
      - Number of connections: (4 bytes int)
      - Connections: up to 8 (variable, 4 bytes each)
    """

    def __init__(self):
        self._file: Optional[BinaryIO] = None

    def write(
        self,
        filepath: str | Path,
        waypoints: List[Waypoint],
        map_name: str = "",
        author: str = "BSP-Waypoint-Generator-HL2DM",
    ) -> None:
        """
        Write waypoints to .rcw file.

        Args:
            filepath: Output file path
            waypoints: List of waypoints to write
            map_name: Map name (optional, for metadata)
            author: Author name (optional, for metadata)
        """
        filepath = Path(filepath)

        # Ensure .rcw extension
        if filepath.suffix.lower() != ".rcw":
            filepath = filepath.with_suffix(".rcw")

        with open(filepath, "wb") as f:
            self._file = f

            # Write header
            self._write_header(len(waypoints))

            # Write each waypoint
            for wp in waypoints:
                self._write_waypoint(wp)

    def _write_header(self, num_waypoints: int) -> None:
        """Write file header."""
        # Magic number
        self._file.write(RCW_MAGIC)

        # Version
        self._file.write(struct.pack("<I", RCW_VERSION))

        # Number of waypoints
        self._file.write(struct.pack("<I", num_waypoints))

    def _write_waypoint(self, wp: Waypoint) -> None:
        """Write a single waypoint."""
        # Position (x, y, z)
        self._file.write(struct.pack("<fff", wp.origin.x, wp.origin.y, wp.origin.z))

        # Flags
        self._file.write(struct.pack("<I", int(wp.flags)))

        # Radius (default 0 for automatic)
        self._file.write(struct.pack("<f", wp.radius))

        # Area (0 for no restriction)
        area = 0
        self._file.write(struct.pack("<i", area))

        # Number of connections (capped at MAX_WAYPOINT_CONNECTIONS)
        num_connections = min(len(wp.connections), MAX_WAYPOINT_CONNECTIONS)
        self._file.write(struct.pack("<I", num_connections))

        # Connection indices
        for i in range(num_connections):
            self._file.write(struct.pack("<i", wp.connections[i]))

        # Pad remaining connections with -1
        for _ in range(MAX_WAYPOINT_CONNECTIONS - num_connections):
            self._file.write(struct.pack("<i", -1))


class RCWExtendedWriter(RCWWriter):
    """
    Extended RCW writer with HL2DM metadata support.

    Writes additional metadata file (.rcm) alongside the waypoint file.
    """

    def write(
        self,
        filepath: str | Path,
        waypoints: List[Waypoint],
        map_name: str = "",
        author: str = "BSP-Waypoint-Generator-HL2DM",
    ) -> None:
        """Write waypoints and metadata."""
        # Write main waypoint file
        super().write(filepath, waypoints, map_name, author)

        # Write metadata file
        self._write_metadata(filepath, waypoints, map_name, author)

    def _write_metadata(
        self,
        filepath: str | Path,
        waypoints: List[Waypoint],
        map_name: str,
        author: str,
    ) -> None:
        """Write extended metadata file."""
        filepath = Path(filepath)
        meta_path = filepath.with_suffix(".rcm")

        with open(meta_path, "w") as f:
            # Header
            f.write(f"// RCBot2 Waypoint Metadata\n")
            f.write(f"// Generated by BSP Waypoint Generator for HL2DM\n")
            f.write(f"// Map: {map_name}\n")
            f.write(f"// Author: {author}\n")
            f.write(f"// Waypoints: {len(waypoints)}\n\n")

            # Waypoint metadata
            for wp in waypoints:
                if wp.metadata.subtype == HL2DMWaypointSubType.SUBTYPE_NONE:
                    continue

                f.write(f"waypoint {wp.index}\n")
                f.write(f"  subtype {wp.metadata.subtype.name}\n")

                if wp.metadata.weapon_priority > 0:
                    f.write(f"  priority {wp.metadata.weapon_priority}\n")

                if wp.metadata.respawn_time > 0:
                    f.write(f"  respawn {wp.metadata.respawn_time}\n")

                if wp.metadata.requires_use:
                    f.write(f"  use 1\n")

                if wp.metadata.target_waypoint >= 0:
                    f.write(f"  target {wp.metadata.target_waypoint}\n")

                f.write(f"end\n\n")


class TextWaypointWriter:
    """
    Writes waypoints in human-readable text format for debugging.
    """

    def write(
        self,
        filepath: str | Path,
        waypoints: List[Waypoint],
        map_name: str = "",
        author: str = "BSP-Waypoint-Generator-HL2DM",
    ) -> None:
        """Write waypoints as text file."""
        filepath = Path(filepath)

        with open(filepath, "w") as f:
            f.write(f"# RCBot2 Waypoints (Text Format)\n")
            f.write(f"# Map: {map_name}\n")
            f.write(f"# Author: {author}\n")
            f.write(f"# Total Waypoints: {len(waypoints)}\n")
            f.write(f"#\n")
            f.write(f"# Format: index x y z flags [connections]\n\n")

            for wp in waypoints:
                # Basic info
                flags_str = self._flags_to_string(wp.flags)
                conn_str = ",".join(str(c) for c in wp.connections)

                f.write(
                    f"{wp.index}: ({wp.origin.x:.1f}, {wp.origin.y:.1f}, {wp.origin.z:.1f})"
                )
                if flags_str:
                    f.write(f" [{flags_str}]")
                if conn_str:
                    f.write(f" -> {conn_str}")
                f.write("\n")

                # Metadata if present
                if wp.metadata.subtype != HL2DMWaypointSubType.SUBTYPE_NONE:
                    f.write(f"  # {wp.metadata.subtype.name}")
                    if wp.metadata.weapon_priority > 0:
                        f.write(f" priority={wp.metadata.weapon_priority}")
                    f.write("\n")

    def _flags_to_string(self, flags: WaypointFlag) -> str:
        """Convert flags to readable string."""
        names = []
        if flags & WaypointFlag.W_FL_JUMP:
            names.append("JUMP")
        if flags & WaypointFlag.W_FL_CROUCH:
            names.append("CROUCH")
        if flags & WaypointFlag.W_FL_LADDER:
            names.append("LADDER")
        if flags & WaypointFlag.W_FL_HEALTH:
            names.append("HEALTH")
        if flags & WaypointFlag.W_FL_AMMO:
            names.append("AMMO")
        if flags & WaypointFlag.W_FL_SNIPER:
            names.append("SNIPER")
        if flags & WaypointFlag.W_FL_TELE_ENTRANCE:
            names.append("TELE_IN")
        if flags & WaypointFlag.W_FL_TELE_EXIT:
            names.append("TELE_OUT")
        if flags & WaypointFlag.W_FL_USE:
            names.append("USE")
        if flags & WaypointFlag.W_FL_FALL:
            names.append("FALL")
        if flags & WaypointFlag.W_FL_BREAKABLE:
            names.append("BREAK")
        if flags & WaypointFlag.W_FL_SPRINT:
            names.append("SPRINT")
        return "|".join(names)


class RCVWriter:
    """
    Writes visibility table (.rcv) for waypoint line-of-sight.

    The visibility table pre-computes which waypoints can see each other,
    improving bot targeting performance.
    """

    def write(
        self,
        filepath: str | Path,
        waypoints: List[Waypoint],
    ) -> None:
        """
        Write visibility table.

        For now, this generates a simple table based on connections
        and distance. Full implementation would use ray tracing.
        """
        filepath = Path(filepath)

        # Ensure .rcv extension
        if filepath.suffix.lower() != ".rcv":
            filepath = filepath.with_suffix(".rcv")

        num_waypoints = len(waypoints)

        # Create visibility matrix (1 bit per pair)
        # For simplicity, mark connected and nearby waypoints as visible
        visibility = self._compute_visibility(waypoints)

        with open(filepath, "wb") as f:
            # Header: number of waypoints
            f.write(struct.pack("<I", num_waypoints))

            # Write visibility bits (packed)
            for i in range(num_waypoints):
                # Pack visibility for waypoint i
                bits = 0
                byte_count = (num_waypoints + 7) // 8

                bytes_data = bytearray(byte_count)
                for j in range(num_waypoints):
                    if visibility[i][j]:
                        bytes_data[j // 8] |= 1 << (j % 8)

                f.write(bytes_data)

    def _compute_visibility(self, waypoints: List[Waypoint]) -> List[List[bool]]:
        """Compute visibility matrix."""
        n = len(waypoints)
        visibility = [[False] * n for _ in range(n)]

        for i, wp_a in enumerate(waypoints):
            # Self is always visible
            visibility[i][i] = True

            # Connected waypoints are visible
            for j in wp_a.connections:
                if j < n:
                    visibility[i][j] = True
                    visibility[j][i] = True

            # Nearby waypoints within line of sight range
            for j, wp_b in enumerate(waypoints):
                if i == j:
                    continue

                dist = wp_a.origin.distance_to(wp_b.origin)
                height_diff = abs(wp_a.origin.z - wp_b.origin.z)

                # Simple visibility: within 1024 units and similar height
                if dist < 1024 and height_diff < 128:
                    visibility[i][j] = True
                    visibility[j][i] = True

        return visibility


def write_waypoints(
    filepath: str | Path,
    waypoints: List[Waypoint],
    map_name: str = "",
    author: str = "BSP-Waypoint-Generator-HL2DM",
    include_metadata: bool = True,
    include_visibility: bool = False,
    debug_text: bool = False,
) -> None:
    """
    Convenience function to write waypoint files.

    Args:
        filepath: Output file path (without extension)
        waypoints: List of waypoints
        map_name: Map name for metadata
        author: Author name for metadata
        include_metadata: Write .rcm metadata file
        include_visibility: Write .rcv visibility file
        debug_text: Write .txt debug file
    """
    filepath = Path(filepath)

    # Write main waypoint file
    if include_metadata:
        writer = RCWExtendedWriter()
    else:
        writer = RCWWriter()

    writer.write(filepath, waypoints, map_name, author)

    # Write visibility table
    if include_visibility:
        vis_writer = RCVWriter()
        vis_writer.write(filepath, waypoints)

    # Write debug text
    if debug_text:
        text_path = filepath.with_suffix(".txt")
        text_writer = TextWaypointWriter()
        text_writer.write(text_path, waypoints, map_name, author)
